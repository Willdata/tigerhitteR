{
    "collab_server" : "",
    "contents" : "#' Complete the hollow dataset\n#'\n#' Take time series dataset and fields, then refill the missing date records and other fields.\n#' @param inPath A path which is the location of uncompleted dataset which must be xlsx file\n#' @param sheet A worksheet name of the dataset\n#' @param dateCol.index Date column\n#' @param outPath A path where the location of xlsx file of completed dataset should be\n#' @param fixedCol.index  A row of column number which should be kept same values with the original\n#' @param uninterpolatedCol.index The column number which should be changed to different value into new record.\n#' @param uninterpolatedCol.newValue The value of a specific column which should be put into the new record.\n#' @import openxlsx zoo Hmisc magrittr\n#' @importFrom utils head install.packages\n#' @importFrom magrittr %>%\n#' @details Real time series sales dataset could be not continuous in 'date' field. e.g., monthly sales data is continuous,\n#'  but discrete in daily data.\n#'\n#'  This hollow dataset is not complete for time series analysis. Function dateRefill.fromFile\n#'  is a transformation which tranforms uncomplete dataset into complete dataset.\n#' @author Will Kuan\n#' @examples # Please refer to the examples of function dateRefill.fromData\n#' @export\ndateRefill.fromFileToExcel <-\n  function(inPath, sheet, dateCol.index, outPath, fixedCol.index, uninterpolatedCol.index, uninterpolatedCol.newValue)\n  {\n    if(!requireNamespace(\"openxlsx\",quietly = TRUE)){\n      install.packages(\"openxlsx\"); requireNamespace(\"openxlsx\", quietly = TRUE)\n      #stop(\"Please install package 'openxlsx'. \")\n    }else{\n      requireNamespace(\"openxlsx\", quietly = TRUE)\n    }\n\n    if(!requireNamespace(\"zoo\", quietly = TRUE)){\n      install.packages(\"zoo\"); requireNamespace(\"zoo\", quietly = TRUE)\n      #stop(\"Please install package 'zoo'. \")\n    }else{\n      requireNamespace(\"zoo\", quietly = TRUE)\n    }\n\n    if(!requireNamespace(\"Hmisc\",quietly = TRUE)){\n      install.packages(\"Hmisc\"); requireNamespace(\"Hmisc\", quietly = TRUE)\n      #stop(\"Please install package 'Hmisc'. \")\n    }else{\n      requireNamespace(\"Hmisc\", quietly = TRUE)\n    }\n\n    if(!requireNamespace(\"magrittr\",quietly = TRUE)){\n      install.packages(\"magrittr\"); requireNamespace(\"magrittr\", quietly = TRUE)\n      #stop(\"Please install package 'magrittr'. \")\n    }else{\n      requireNamespace(\"magrittr\", quietly = TRUE)\n    }\n\n    data <- openxlsx::read.xlsx(inPath, sheet)\n\n    #=============\n    data[,dateCol.index] <- zoo::as.Date(data[,dateCol.index], origin = \"1899-12-30\")\n    colNameVector <- colnames(data)\n\n    colnames(data)[dateCol.index] <- \"Date\"\n\n    data$Date <- as.POSIXlt(data$Date) # transform to POSIXlt type\n\n    year.list <- levels(factor(data$Date$year + 1900))\n\n    ### sorting data\n    data <- data[order(data$Date, decreasing = FALSE),]\n\n    ### building an empty data frame\n    final.data <- data.frame(data[,1:length(colNameVector)])\n    final.data[,] <- NA\n    final.data$Date <- as.POSIXlt(final.data$Date)\n\n    year <- substr(data[1, dateCol.index],1,4)\n    origin <- paste(year, \"-01-01\", sep = \"\")\n    origin <- zoo::as.Date(origin)\n    diff <- zoo::as.Date(data[1, dateCol.index])-origin\n\n    #=============\n    daySum <- sprintf(\"%s-01-01\", year.list) %>%\n      zoo::as.Date()\n\n    daySum <- mapply(Hmisc::yearDays, daySum) %>%\n      sum()\n\n    daySum <- magrittr::subtract(daySum, diff) %>%\n      as.numeric()\n\n    final.data[1:daySum,] <- NA # remove first few null days because data is not start on 1/1\n    final.data[, dateCol.index] <- seq(data[1, dateCol.index], by = \"1 days\", length.out = daySum)\n\n    ### duplicate identical column names\n    colnames(data) <- names(final.data)\n\n    ### copy identical record from original data\n    my.index <- match(data$Date, as.POSIXlt(final.data$Date))\n    final.data[my.index,] <- data[,]\n\n    ### copy fixedCol.value from original data to new records\n    final.data <- head(final.data, which(final.data$Date == data$Date[length(data$Date)]))\n\n    #==============\n    final.data[which(is.na(final.data[, fixedCol.index[1]])), fixedCol.index] <- data[1, fixedCol.index]\n    final.data[which(is.na(final.data[, uninterpolatedCol.index[1]])), uninterpolatedCol.index] <- uninterpolatedCol.newValue\n\n    #==============\n    final.data$Date <- zoo::as.Date(final.data$Date) # for correcting date time in excel\n\n    colnames(final.data) <- colNameVector\n\n\n    ### output data into excel file\n    openxlsx::write.xlsx(final.data, file = outPath)\n\n  }\n\n#' Complete the hollow dataset\n#'\n#' Take time series dataset and fields, then refill the missing date records and other fields.\n#' @param data The data.frame dataset which is ready to be processed\n#' @param dateCol.index Date column\n#' @param fixedCol.index  A row of column number which should be kept same values with the original\n#' @param uninterpolatedCol.index The column number which should be changed to different value into new record.\n#' @param uninterpolatedCol.newValue The value of a specific column which should be put into the new record.\n#' @import zoo Hmisc magrittr\n#' @importFrom utils head install.packages\n#' @importFrom magrittr %>%\n#' @return The dataset which is completed.\n#' @details Real time series sales dataset could be not continuous in 'date' field. e.g., monthly sales data is continuous,\n#'  but discrete in daily data.\n#'\n#'  This hollow dataset is not complete for time series analysis. Function dateRefill.fromFile\n#'  is a transformation which tranforms uncomplete dataset into complete dataset.\n#' @author Will Kuan\n#' @examples # mydata <- data.example\n#' # mydata.final <- dateRefill.fromData(data = mydata,dateCol = 2,fixedVec = c(3:10),\n#' #                                     uninterpolatedCol.index = 11,uninterpolatedCol.newValue = 0)\n#' @export\ndateRefill.fromData <-\n  function(data, dateCol.index, fixedCol.index, uninterpolatedCol.index, uninterpolatedCol.newValue)\n  {\n    if(!requireNamespace(\"zoo\", quietly = TRUE)){\n      install.packages(\"zoo\"); requireNamespace(\"zoo\", quietly = TRUE)\n      #stop(\"Please install package 'zoo'. \")\n    }else{\n      requireNamespace(\"zoo\", quietly = TRUE)\n    }\n\n    if(!requireNamespace(\"Hmisc\",quietly = TRUE)){\n      install.packages(\"Hmisc\"); requireNamespace(\"Hmisc\", quietly = TRUE)\n      #stop(\"Please install package 'Hmisc'. \")\n    }else{\n      requireNamespace(\"Hmisc\", quietly = TRUE)\n    }\n\n    if(!requireNamespace(\"magrittr\",quietly = TRUE)){\n      install.packages(\"magrittr\"); requireNamespace(\"magrittr\", quietly = TRUE)\n      #stop(\"Please install package 'magrittr'. \")\n    }else{\n      requireNamespace(\"magrittr\", quietly = TRUE)\n    }\n\n    data <- data.frame(data)\n\n    #=============\n    data[,dateCol.index] <- zoo::as.Date(data[,dateCol.index], origin = \"1899-12-30\")\n    colNameVector <- colnames(data)\n\n    colnames(data)[dateCol.index] <- \"Date\"\n\n    data$Date <- as.POSIXlt(data$Date) # transform to POSIXlt type\n\n    year.list <- levels(factor(data$Date$year + 1900))\n\n    ### sorting data\n    data <- data[order(data$Date, decreasing = FALSE),]\n\n    ### building an empty data frame\n    final.data <- data.frame(data[,1:length(colNameVector)])\n    final.data[,] <- NA\n    final.data$Date <- as.POSIXlt(final.data$Date)\n\n    year <- substr(data[1, dateCol.index],1,4)\n    origin <- paste(year, \"-01-01\", sep = \"\")\n    origin <- zoo::as.Date(origin)\n    diff <- zoo::as.Date(data[1, dateCol.index])-origin\n\n    #=============\n    daySum <- sprintf(\"%s-01-01\", year.list) %>%\n      zoo::as.Date()\n\n    daySum <- mapply(Hmisc::yearDays, daySum) %>%\n      sum()\n\n    daySum <- magrittr::subtract(daySum, diff) %>%\n      as.numeric()\n\n    final.data[1:daySum,] <- NA # remove first few null days because data is not start on 1/1\n    final.data[, dateCol.index] <- seq(data[1, dateCol.index], by = \"1 days\", length.out = daySum)\n\n    ### duplicate identical column names\n    colnames(data) <- names(final.data)\n\n    ### copy identical record from original data\n    my.index <- match(data$Date, as.POSIXlt(final.data$Date))\n    final.data[my.index,] <- data[,]\n\n    ### copy fixedCol.value from original data to new records\n    final.data <- head(final.data, which(final.data$Date == data$Date[length(data$Date)]))\n\n    #==============\n    final.data[which(is.na(final.data[, fixedCol.index[1]])), fixedCol.index] <- data[1, fixedCol.index]\n    final.data[which(is.na(final.data[, uninterpolatedCol.index[1]])), uninterpolatedCol.index] <- uninterpolatedCol.newValue\n\n    #==============\n    final.data$Date <- zoo::as.Date(final.data$Date) # for correcting date time in excel\n\n    colnames(final.data) <- colNameVector\n\n    ### return data\n    return(final.data)\n  }\n",
    "created" : 1475418134270.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "490363994",
    "id" : "8518F03E",
    "lastKnownWriteTime" : 1475426712,
    "last_content_update" : 1475426713797,
    "path" : "/Volumes/ADATA UFD/_MyPackage/tigerhitteR/R/tigerhitteR.R",
    "project_path" : "R/tigerhitteR.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}